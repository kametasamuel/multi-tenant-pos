// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Business Type Enum - 4 Main Sectors
// Legacy types (RESTAURANT, SALON, PHARMACY, GROCERY, ELECTRONICS, CLOTHING, OTHER)
// are kept for backward compatibility with existing data
enum BusinessType {
  // Main 4 Sectors (used for new signups)
  RETAIL            // Shops, electronics, groceries, pharmacy, clothing & general merchandise
  FOOD_AND_BEVERAGE // Restaurants, cafes, bars, quick service & food trucks
  HOSPITALITY       // Hotels, lodges, guest houses, rentals & vacation properties
  SERVICES          // Salons, spas, auto repair, laundry & professional services

  // Legacy types (for backward compatibility)
  RESTAURANT        // Maps to FOOD_AND_BEVERAGE
  SALON             // Maps to SERVICES
  PHARMACY          // Maps to RETAIL
  GROCERY           // Maps to RETAIL
  ELECTRONICS       // Maps to RETAIL
  CLOTHING          // Maps to RETAIL
  OTHER             // Generic fallback
}

// Subscription Tier: Plans that control feature access
model SubscriptionTier {
  id                String   @id @default(uuid())
  name              String   @unique // e.g., "Basic", "Professional", "Enterprise"
  description       String?
  monthlyPrice      Float    @default(0)
  annualPrice       Float    @default(0)
  maxUsers          Int      @default(5)
  maxBranches       Int      @default(1)
  maxProducts       Int      @default(100)
  isActive          Boolean  @default(true)
  sortOrder         Int      @default(0)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  tenants           Tenant[]
  features          TierFeature[]

  @@map("subscription_tiers")
}

// Feature definitions for tier-based access control
model Feature {
  id                String   @id @default(uuid())
  code              String   @unique // e.g., "analytics", "smart_fifo", "multi_branch", "api_access"
  name              String           // Human-readable name
  description       String?
  category          String   @default("general") // e.g., "analytics", "inventory", "integrations"
  isActive          Boolean  @default(true)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  tierFeatures      TierFeature[]

  @@map("features")
}

// Many-to-many: Features enabled for each tier
model TierFeature {
  id                String   @id @default(uuid())
  tierId            String
  featureId         String
  isEnabled         Boolean  @default(true)
  createdAt         DateTime @default(now())

  tier              SubscriptionTier @relation(fields: [tierId], references: [id], onDelete: Cascade)
  feature           Feature          @relation(fields: [featureId], references: [id], onDelete: Cascade)

  @@unique([tierId, featureId])
  @@map("tier_features")
}

// Global Tax Configuration pushed to tenants
model TaxConfig {
  id                String   @id @default(uuid())
  country           String           // Country code (GH, NG, KE, US, etc.)
  name              String           // e.g., "VAT", "E-Levy", "NHIL"
  rate              Float            // Tax rate as decimal
  isCompound        Boolean  @default(false) // Applied on top of other taxes
  isActive          Boolean  @default(true)
  effectiveFrom     DateTime @default(now())
  effectiveTo       DateTime?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@index([country, isActive])
  @@map("tax_configs")
}

// Admin Impersonation Log: Audit trail for "login as tenant" actions
model ImpersonationLog {
  id                String   @id @default(uuid())
  adminId           String           // Super admin who impersonated
  tenantId          String           // Tenant that was accessed
  reason            String           // Why impersonation was needed
  startedAt         DateTime @default(now())
  endedAt           DateTime?
  ipAddress         String?
  userAgent         String?
  actionsPerformed  String?  @db.Text // JSON array of actions taken

  @@index([adminId, startedAt])
  @@index([tenantId, startedAt])
  @@map("impersonation_logs")
}

// Multi-Tenant: Each business has a unique ID
model Tenant {
  id                String       @id @default(uuid())
  businessName      String       @unique
  slug              String?      @unique // URL slug for tenant (e.g., "trim" for smartpos.com/trim)
  businessType      BusinessType @default(RETAIL)
  businessSubtype   String?      // Specific subtype (grocery, salon, restaurant, hotel, etc.)
  businessLogo      String?
  country           String       @default("GH") // Country code for tax/locale
  currency          String       @default("USD") // Currency code (USD, GHS, NGN, KES, etc.)
  currencySymbol    String       @default("$")   // Currency symbol ($, GH₵, ₦, KSh, etc.)
  taxRate           Float        @default(0)     // Tax rate as decimal (e.g., 0.08 for 8%)
  tierId            String?      // Subscription tier
  subscriptionStart DateTime     @default(now())
  subscriptionEnd   DateTime
  gracePeriodEnd    DateTime?    // Extended access period after subscription expires
  isActive          Boolean      @default(true)
  isInGracePeriod   Boolean      @default(false) // True when subscription expired but in grace
  lastActivityAt    DateTime?    // Last transaction or login time (for health tracking)
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt

  tier              SubscriptionTier? @relation(fields: [tierId], references: [id])
  users             User[]
  products          Product[]
  sales             Sale[]
  expenses          Expense[]
  customers         Customer[]
  auditLogs         AuditLog[]
  securityRequests  SecurityRequest[]
  branches          Branch[]
  branchRequests    BranchRequest[]
  // Retail module relations
  suppliers         Supplier[]
  purchaseOrders    PurchaseOrder[]
  stockTransfers    StockTransfer[]
  returns           Return[]
  productCategories ProductCategory[]
  stockAdjustments  StockAdjustment[]
  // Services module relations
  attendants        Attendant[]

  @@index([tierId])
  @@index([country])
  @@index([isActive])                    // Filter active tenants
  @@index([businessType])                // Filter by business type
  @@index([businessType, businessSubtype]) // Filter by type and subtype
  @@index([subscriptionEnd])             // Find expiring subscriptions
  @@index([isActive, subscriptionEnd])   // Combined for subscription queries
  @@map("tenants")
}

// Users: Staff (Cashier) and Admin
model User {
  id             String   @id @default(uuid())
  username       String?  // Optional for ATTENDANT role
  password       String?  // Hashed password (optional for ATTENDANT role)
  fullName       String
  email          String?  // Personal email (editable by owner)
  phone          String?  // Personal phone (editable by owner)
  address        String?  // Personal address
  gender         String?  // MALE, FEMALE, OTHER, PREFER_NOT_TO_SAY
  dateOfBirth    DateTime? // For calculating age
  profileImage   String?  // URL path to profile image
  role           Role     @default(CASHIER)
  isActive       Boolean  @default(true)
  isSuperAdmin   Boolean  @default(false)
  // ATTENDANT-specific fields
  specialty      String?  // e.g., "Hair Stylist", "Nail Tech", "Barber" (for ATTENDANT)
  commissionRate Float?   // Commission percentage (e.g., 30 = 30%) (for ATTENDANT)
  tenantId       String
  branchId       String?  // Optional branch assignment
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  tenant                  Tenant            @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  branch                  Branch?           @relation(fields: [branchId], references: [id])
  sales                   Sale[]            @relation("CashierSales")
  voidedSales             Sale[]            @relation("VoidedSales")
  expenses                Expense[]
  auditLogs               AuditLog[]
  requestsMade            SecurityRequest[] @relation("RequestsMade")
  requestsReviewed        SecurityRequest[] @relation("RequestsReviewed")
  branchRequestsMade      BranchRequest[]   @relation("BranchRequestsMade")
  branchRequestsReviewed  BranchRequest[]   @relation("BranchRequestsReviewed")
  // Retail module relations
  purchaseOrdersCreated   PurchaseOrder[]   @relation("PurchaseOrdersCreated")
  transfersInitiated      StockTransfer[]   @relation("TransfersInitiated")
  transfersReceived       StockTransfer[]   @relation("TransfersReceived")
  returnsProcessed        Return[]          @relation("ReturnsProcessed")
  stockAdjustments        StockAdjustment[] @relation("StockAdjustments")

  @@unique([username, tenantId]) // Username unique per tenant
  @@index([branchId])
  @@index([tenantId])              // Critical for tenant user lookups
  @@index([tenantId, role])        // Filter users by role within tenant
  @@index([tenantId, isActive])    // Active users per tenant
  @@map("users")
}

// Attendant: Service providers (stylists, technicians, etc.) - no login credentials
model Attendant {
  id             String   @id @default(uuid())
  fullName       String
  phone          String?
  email          String?
  profileImage   String?
  specialty      String?  // e.g., "Hair Stylist", "Nail Tech", "Barber"
  commissionRate Float    @default(0)  // Commission percentage (e.g., 30 = 30%)
  isActive       Boolean  @default(true)
  tenantId       String
  branchId       String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  tenant         Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  branch         Branch?    @relation(fields: [branchId], references: [id])
  saleItems      SaleItem[] @relation("AttendantSales")

  @@index([tenantId])
  @@index([tenantId, isActive])
  @@index([branchId])
  @@map("attendants")
}

enum Role {
  CASHIER
  MANAGER
  OWNER
  ADMIN      // Kept for backward compatibility, same as OWNER
  ATTENDANT  // Service provider (stylist, technician) - no login credentials
}

// Products: Inventory items and services
model Product {
  id          String   @id @default(uuid())
  name        String
  description String?
  image       String?  // Product image path
  type        ProductType @default(PRODUCT) // PRODUCT or SERVICE
  categoryId  String?      // Reference to ProductCategory
  customCategory String?   // Legacy: Custom category tag (e.g., "Hair Products", "Drinks")
  sku         String?      // Stock Keeping Unit - internal code
  barcode     String?      // External barcode (UPC, EAN, etc.)
  costPrice   Float    @default(0)
  sellingPrice Float
  stockQuantity Int    @default(0)
  lowStockThreshold Int @default(10)
  reorderPoint Int     @default(5)    // When to reorder
  reorderQty   Int     @default(10)   // How much to reorder
  expiryDate  DateTime?        // Product expiry date (optional)
  weight      Float?           // Weight in kg (for shipping)
  dimensions  String?          // LxWxH in cm (for shipping)
  isActive    Boolean  @default(true)
  trackInventory Boolean @default(true) // False for services
  tenantId    String
  branchId    String?          // Branch that owns this product
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  branch      Branch?  @relation(fields: [branchId], references: [id])
  category    ProductCategory? @relation(fields: [categoryId], references: [id])
  saleItems   SaleItem[]
  // Retail module relations
  suppliers         ProductSupplier[]
  purchaseOrderItems PurchaseOrderItem[]
  stockTransferItems StockTransferItem[]
  returnItems       ReturnItem[]
  stockAdjustments  StockAdjustment[]

  @@index([tenantId, name])
  @@index([branchId])
  @@index([tenantId, isActive])      // Active products per tenant
  @@index([tenantId, type])          // Filter by type
  @@index([categoryId])              // Filter by category
  @@index([barcode])                 // Quick barcode lookups (POS scanning)
  @@index([sku])                     // SKU lookups
  @@map("products")
}

// Product Type: Physical product or service
enum ProductType {
  PRODUCT
  SERVICE
}

// Customers: Customer records for loyalty and tracking
model Customer {
  id          String   @id @default(uuid())
  name        String
  phone       String?
  email       String?
  address     String?
  notes       String?
  totalSpent  Float    @default(0)
  visitCount  Int      @default(0)
  tenantId    String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  sales       Sale[]
  returns     Return[] // Retail: returns by this customer

  @@index([tenantId, name])
  @@index([tenantId, phone])
  @@map("customers")
}

// Sales: Transaction records
model Sale {
  id          String   @id @default(uuid())
  transactionNumber String
  totalAmount Float
  discountAmount Float @default(0)
  finalAmount Float
  paymentMethod PaymentMethod
  paymentStatus String @default("completed") // completed, cancelled, voided
  cashierId   String
  customerId  String?
  tenantId    String
  branchId    String?  // Optional branch assignment
  // Void tracking fields
  voidedById  String?  // User who voided the sale
  voidedAt    DateTime? // When the sale was voided
  voidReason  String?  // Reason for voiding
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  cashier           User              @relation("CashierSales", fields: [cashierId], references: [id])
  voidedBy          User?             @relation("VoidedSales", fields: [voidedById], references: [id])
  customer          Customer?         @relation(fields: [customerId], references: [id])
  tenant            Tenant            @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  branch            Branch?           @relation(fields: [branchId], references: [id])
  items             SaleItem[]
  securityRequests  SecurityRequest[]
  returns           Return[]          // Retail: returns for this sale

  @@index([tenantId, createdAt])
  @@index([cashierId, createdAt])
  @@index([branchId])
  @@index([paymentStatus])                     // Filter by payment status
  @@index([tenantId, paymentStatus])           // Voided sales per tenant
  @@index([createdAt])                         // Date range queries (super admin)
  @@index([tenantId, paymentMethod, createdAt]) // Payment method analytics
  @@index([voidedById])                        // Lookup sales voided by user
  @@map("sales")
}

model SaleItem {
  id          String   @id @default(uuid())
  saleId      String
  productId   String
  quantity    Int
  unitPrice   Float
  discount    Float    @default(0)
  subtotal    Float
  attendantId String?  // Optional attendant for SERVICES business type
  createdAt   DateTime @default(now())

  sale        Sale       @relation(fields: [saleId], references: [id], onDelete: Cascade)
  product     Product    @relation(fields: [productId], references: [id])
  attendant   Attendant? @relation("AttendantSales", fields: [attendantId], references: [id])
  returnItems ReturnItem[] // Retail: items returned from this sale item

  @@index([saleId])        // Faster sale item lookups
  @@index([productId])     // Product sales analysis
  @@index([attendantId])   // Attendant performance analysis
  @@map("sale_items")
}

enum PaymentMethod {
  CASH
  CARD
  MOMO
  BANK_TRANSFER
}

// Expenses: Business expenses
model Expense {
  id          String   @id @default(uuid())
  description String
  amount      Float
  category    String   // e.g., "Rent", "Electricity", "Internet", "Petty Cash"
  recordedBy  String   // User ID who recorded it
  tenantId    String
  branchId    String?  // Branch where expense was recorded
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  recorder    User     @relation(fields: [recordedBy], references: [id])
  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  branch      Branch?  @relation(fields: [branchId], references: [id])

  @@index([tenantId, createdAt])
  @@index([branchId])
  @@map("expenses")
}

// Audit Log: Track sensitive actions
model AuditLog {
  id          String   @id @default(uuid())
  action      String   // e.g., "drawer_opened", "transaction_voided", "price_changed"
  description String?
  userId      String
  tenantId    String
  branchId    String?  // Branch where action occurred
  metadata    String?  // JSON string for additional data
  createdAt   DateTime @default(now())

  user        User     @relation(fields: [userId], references: [id])
  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  branch      Branch?  @relation(fields: [branchId], references: [id])

  @@index([tenantId, createdAt])
  @@index([branchId])
  @@map("audit_logs")
}

// Security Request Type enum
enum SecurityRequestType {
  VOID
  REVIEW
}

// Security Request Status enum
enum SecurityRequestStatus {
  PENDING
  APPROVED
  REJECTED
}

// Security Requests: Void and review requests from cashiers to managers
model SecurityRequest {
  id            String                @id @default(uuid())
  type          SecurityRequestType
  status        SecurityRequestStatus @default(PENDING)
  reason        String                // Reason provided by requester
  saleId        String?               // Related sale (for void requests)
  itemName      String                // Item or transaction description
  amount        Float                 @default(0)
  requesterId   String                // User who made the request
  reviewerId    String?               // Manager who reviewed the request
  reviewedAt    DateTime?
  tenantId      String
  branchId      String?               // Branch where request was made
  createdAt     DateTime              @default(now())
  updatedAt     DateTime              @updatedAt

  requester     User                  @relation("RequestsMade", fields: [requesterId], references: [id])
  reviewer      User?                 @relation("RequestsReviewed", fields: [reviewerId], references: [id])
  tenant        Tenant                @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  sale          Sale?                 @relation(fields: [saleId], references: [id])
  branch        Branch?               @relation(fields: [branchId], references: [id])

  @@index([tenantId, status])
  @@index([requesterId])
  @@index([branchId])
  @@map("security_requests")
}

// Branch: Physical business locations
model Branch {
  id          String   @id @default(uuid())
  name        String
  address     String?
  phone       String?
  isActive    Boolean  @default(true)
  isMain      Boolean  @default(false)
  tenantId    String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  tenant            Tenant            @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  users             User[]
  sales             Sale[]
  products          Product[]
  expenses          Expense[]
  auditLogs         AuditLog[]
  securityRequests  SecurityRequest[]
  // Retail module relations
  purchaseOrders    PurchaseOrder[]
  transfersFrom     StockTransfer[]   @relation("TransfersFrom")
  transfersTo       StockTransfer[]   @relation("TransfersTo")
  returns           Return[]
  stockAdjustments  StockAdjustment[]
  // Services module relations
  attendants        Attendant[]

  @@index([tenantId])
  @@map("branches")
}

// Branch Request Status enum
enum BranchRequestStatus {
  PENDING
  APPROVED
  REJECTED
}

// Branch Requests: Owner requests for new branches, reviewed by super admin
model BranchRequest {
  id              String              @id @default(uuid())
  branchName      String
  address         String?
  phone           String?
  reason          String
  status          BranchRequestStatus @default(PENDING)
  requesterId     String
  reviewerId      String?
  reviewedAt      DateTime?
  rejectionReason String?
  tenantId        String
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt

  requester       User     @relation("BranchRequestsMade", fields: [requesterId], references: [id])
  reviewer        User?    @relation("BranchRequestsReviewed", fields: [reviewerId], references: [id])
  tenant          Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId, status])
  @@map("branch_requests")
}

// Application Status enum
enum ApplicationStatus {
  PENDING
  APPROVED
  REJECTED
}

// Tenant Applications: New business signups awaiting approval
model TenantApplication {
  id                String            @id @default(uuid())
  businessName      String
  businessType      BusinessType      @default(RETAIL)
  businessSubtype   String?           // Specific subtype (grocery, salon, restaurant, hotel, etc.)
  businessEmail     String            @unique
  businessPhone     String?
  businessLogo      String?
  businessAddress   String?

  // Admin user details (becomes tenant admin on approval)
  ownerFullName     String
  ownerEmail        String
  ownerPhone        String?
  password          String            // Hashed - used when creating admin user

  // Status tracking
  status            ApplicationStatus @default(PENDING)
  slug              String?           // URL slug assigned by super admin on approval
  rejectionReason   String?
  reviewedBy        String?
  reviewedAt        DateTime?

  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt

  @@index([status, createdAt])
  @@map("tenant_applications")
}

// =============================================================================
// RETAIL MODULE - Suppliers, Purchase Orders, Stock Transfers, Returns
// =============================================================================

// Supplier: Vendors that provide products
model Supplier {
  id            String   @id @default(uuid())
  name          String
  contactPerson String?
  email         String?
  phone         String?
  address       String?
  notes         String?
  isActive      Boolean  @default(true)
  tenantId      String
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  tenant          Tenant          @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  products        ProductSupplier[]
  purchaseOrders  PurchaseOrder[]

  @@index([tenantId])
  @@index([tenantId, isActive])
  @@map("suppliers")
}

// Many-to-many: Products can have multiple suppliers with different costs
model ProductSupplier {
  id            String   @id @default(uuid())
  productId     String
  supplierId    String
  supplierSku   String?          // Supplier's product code
  costPrice     Float            // Cost from this supplier
  isPreferred   Boolean  @default(false) // Primary supplier for this product
  leadTimeDays  Int      @default(0)     // Days to receive from supplier
  minOrderQty   Int      @default(1)     // Minimum order quantity
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  product       Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  supplier      Supplier @relation(fields: [supplierId], references: [id], onDelete: Cascade)

  @@unique([productId, supplierId])
  @@index([supplierId])
  @@map("product_suppliers")
}

// Purchase Order Status
enum PurchaseOrderStatus {
  DRAFT
  PENDING      // Sent to supplier, awaiting delivery
  PARTIAL      // Partially received
  RECEIVED     // Fully received
  CANCELLED
}

// Purchase Order: Orders to suppliers for restocking
model PurchaseOrder {
  id              String              @id @default(uuid())
  orderNumber     String              // PO-YYYYMMDD-XXXX
  supplierId      String
  status          PurchaseOrderStatus @default(DRAFT)
  subtotal        Float               @default(0)
  taxAmount       Float               @default(0)
  shippingCost    Float               @default(0)
  totalAmount     Float               @default(0)
  notes           String?
  expectedDate    DateTime?           // Expected delivery date
  receivedDate    DateTime?           // Actual received date
  createdById     String              // User who created the PO
  tenantId        String
  branchId        String?             // Branch receiving the stock
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt

  supplier        Supplier            @relation(fields: [supplierId], references: [id])
  createdBy       User                @relation("PurchaseOrdersCreated", fields: [createdById], references: [id])
  tenant          Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  branch          Branch?             @relation(fields: [branchId], references: [id])
  items           PurchaseOrderItem[]

  @@index([tenantId, status])
  @@index([supplierId])
  @@index([branchId])
  @@index([tenantId, createdAt])
  @@map("purchase_orders")
}

// Purchase Order Item: Line items in a purchase order
model PurchaseOrderItem {
  id              String   @id @default(uuid())
  purchaseOrderId String
  productId       String
  quantity        Int               // Ordered quantity
  receivedQty     Int      @default(0) // Received quantity
  unitCost        Float             // Cost per unit
  subtotal        Float             // quantity * unitCost
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  purchaseOrder   PurchaseOrder @relation(fields: [purchaseOrderId], references: [id], onDelete: Cascade)
  product         Product       @relation(fields: [productId], references: [id])

  @@index([purchaseOrderId])
  @@index([productId])
  @@map("purchase_order_items")
}

// Stock Transfer Status
enum StockTransferStatus {
  PENDING      // Awaiting approval/shipment
  IN_TRANSIT   // Being transferred
  RECEIVED     // Received at destination
  CANCELLED
}

// Stock Transfer: Move inventory between branches
model StockTransfer {
  id              String              @id @default(uuid())
  transferNumber  String              // TRF-YYYYMMDD-XXXX
  fromBranchId    String
  toBranchId      String
  status          StockTransferStatus @default(PENDING)
  notes           String?
  initiatedById   String              // User who initiated
  receivedById    String?             // User who received
  shippedAt       DateTime?
  receivedAt      DateTime?
  tenantId        String
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt

  fromBranch      Branch              @relation("TransfersFrom", fields: [fromBranchId], references: [id])
  toBranch        Branch              @relation("TransfersTo", fields: [toBranchId], references: [id])
  initiatedBy     User                @relation("TransfersInitiated", fields: [initiatedById], references: [id])
  receivedBy      User?               @relation("TransfersReceived", fields: [receivedById], references: [id])
  tenant          Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  items           StockTransferItem[]

  @@index([tenantId, status])
  @@index([fromBranchId])
  @@index([toBranchId])
  @@index([tenantId, createdAt])
  @@map("stock_transfers")
}

// Stock Transfer Item: Products being transferred
model StockTransferItem {
  id              String   @id @default(uuid())
  stockTransferId String
  productId       String
  quantity        Int               // Quantity to transfer
  receivedQty     Int      @default(0) // Quantity actually received
  createdAt       DateTime @default(now())

  stockTransfer   StockTransfer @relation(fields: [stockTransferId], references: [id], onDelete: Cascade)
  product         Product       @relation(fields: [productId], references: [id])

  @@index([stockTransferId])
  @@index([productId])
  @@map("stock_transfer_items")
}

// Return Type
enum ReturnType {
  REFUND       // Money back
  EXCHANGE     // Swap for another product
  STORE_CREDIT // Credit for future purchase
}

// Return Status
enum ReturnStatus {
  PENDING      // Awaiting processing
  APPROVED     // Approved, awaiting completion
  COMPLETED    // Return processed
  REJECTED     // Return denied
}

// Return: Customer returns and exchanges
model Return {
  id              String       @id @default(uuid())
  returnNumber    String       // RTN-YYYYMMDD-XXXX
  saleId          String       // Original sale
  type            ReturnType   @default(REFUND)
  status          ReturnStatus @default(PENDING)
  reason          String       // Why customer is returning
  totalAmount     Float        @default(0) // Total refund/credit amount
  notes           String?
  processedById   String?      // Staff who processed
  processedAt     DateTime?
  customerId      String?
  tenantId        String
  branchId        String?
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt

  sale            Sale         @relation(fields: [saleId], references: [id])
  processedBy     User?        @relation("ReturnsProcessed", fields: [processedById], references: [id])
  customer        Customer?    @relation(fields: [customerId], references: [id])
  tenant          Tenant       @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  branch          Branch?      @relation(fields: [branchId], references: [id])
  items           ReturnItem[]

  @@index([tenantId, status])
  @@index([saleId])
  @@index([customerId])
  @@index([branchId])
  @@index([tenantId, createdAt])
  @@map("returns")
}

// Return Item: Products being returned
model ReturnItem {
  id              String   @id @default(uuid())
  returnId        String
  productId       String
  saleItemId      String?  // Reference to original sale item
  quantity        Int      // Quantity being returned
  unitPrice       Float    // Price at time of sale
  subtotal        Float    // Refund amount for this item
  condition       String?  // e.g., "unopened", "defective", "damaged"
  restockable     Boolean  @default(true) // Can be resold?
  createdAt       DateTime @default(now())

  return          Return   @relation(fields: [returnId], references: [id], onDelete: Cascade)
  product         Product  @relation(fields: [productId], references: [id])
  saleItem        SaleItem? @relation(fields: [saleItemId], references: [id])

  @@index([returnId])
  @@index([productId])
  @@map("return_items")
}

// Product Category: Organize products into categories
model ProductCategory {
  id          String   @id @default(uuid())
  name        String
  description String?
  parentId    String?          // For subcategories
  sortOrder   Int      @default(0)
  isActive    Boolean  @default(true)
  tenantId    String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  parent      ProductCategory?  @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children    ProductCategory[] @relation("CategoryHierarchy")
  tenant      Tenant            @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  products    Product[]

  @@unique([name, tenantId])
  @@index([tenantId])
  @@index([parentId])
  @@map("product_categories")
}

// Stock Adjustment: Track inventory adjustments (damage, theft, counting errors)
model StockAdjustment {
  id            String   @id @default(uuid())
  productId     String
  adjustmentType String  // "damage", "theft", "count", "expiry", "other"
  quantity      Int      // Positive or negative
  previousQty   Int      // Stock before adjustment
  newQty        Int      // Stock after adjustment
  reason        String   // Detailed reason
  adjustedById  String   // User who made adjustment
  tenantId      String
  branchId      String?
  createdAt     DateTime @default(now())

  product       Product  @relation(fields: [productId], references: [id])
  adjustedBy    User     @relation("StockAdjustments", fields: [adjustedById], references: [id])
  tenant        Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  branch        Branch?  @relation(fields: [branchId], references: [id])

  @@index([tenantId, createdAt])
  @@index([productId])
  @@index([branchId])
  @@map("stock_adjustments")
}
